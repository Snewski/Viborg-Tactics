---
title: "Test_Scoring"
author: "P.H.W"
date: "2024-10-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Install packages if needed...
library(dplyr)
library(tidyr)

```



```{r, loading data}

# Set the path to your logfiles directory
file_path <- 'logfiles/'

# Get a list of all CSV files in the directory
files <- list.files(file_path, pattern = "*.csv", full.names = TRUE)

# Read and combine all CSV files into a single data frame
combined_data <- do.call(rbind, lapply(files, read.csv))

```


```{r, data cleaning}

# Renaming and starting trial order from 1 instead of 0
combined_data$Trial_Number <- combined_data$X+1
combined_data$X <- NULL


# Remove "Pictures/" and ".mp4" from the Tactic column
combined_data$Tactic <- gsub("Pictures/|\\.mp4$", "", combined_data$Tactic)

mapping <- c(
  "1" = "Highest free man",
  "2" = "Link out",
  "3" = "Switch play to open lines",
  "4" = "Pass it over the opponent"
)

combined_data$Highest_Priority <- mapping[
  as.character(as.numeric(gsub(".*_(\\d+)$", "\\1", combined_data$Tactic)))
]


```




```{r, max scores}
## Testing ##

# generating toy data:
highest_prio <- sample(1:4, 100, replace = TRUE)
answer <- sample(c(round(runif(85,1,4),0),round(runif(15,5,8),0)))
participant <- c(rep(1, 50), rep(2, 50))
test <- data.frame(participant,highest_prio,answer)
#table(highest_prio)
#table(answer)
#test %>% group_by(participant) %>% count(answer)
#test %>% group_by(participant) %>% count(highest_prio)


## Max scores for each participant in 2 steps ## 

# Step 1: Calculate base max score for each highest_prio category
base_scores <- test %>%
  group_by(participant, highest_prio) %>%
  summarise(
    base_score = 3 * n(),  # 3 times the occurrence of each highest_prio
    .groups = 'drop'
  ) %>%
  rename(category = highest_prio)


# Step 2: Add additional points for mismatches based on answer (non-first priority answers that's still considered 'good')
mismatch_scores <- test %>%
  filter(answer %in% c(2, 3, 4) & answer != highest_prio) %>%  # mismatches where answer is 2, 3, or 4
  group_by(participant, answer) %>%
  summarise(
    mismatch_score = n(),  # 1 point for each mismatch, counted per answer category
    .groups = 'drop'
  ) %>%
  rename(category = answer)

# Combine base scores and mismatch scores 
# in long format
theoretical_max_scores_long <- base_scores %>%
  full_join(mismatch_scores, by = c("participant", "category")) %>%
  mutate(
    max_score = base_score + coalesce(mismatch_score, 0)  # Add mismatch_score to base_score, replace NA with 0
  ) %>%
  select(participant, category, max_score)

# converted to wide format
theoretical_max_scores_wide <- theoretical_max_scores_long %>% 
  pivot_wider(
    names_from = category,
    values_from = max_score,
    names_prefix = "category_",
    values_fill = list(total_score = 0)
  )




```



```{r, scoring}

## Scoring ##

# Defining a mapping for penalty relationships for the principles
penalty_map <- c(`5` = 1, `6` = 2, `7` = 3, `8` = 4)

# Calculate scores
scores <- test %>%
  rowwise() %>%
  mutate(
    # Case 1: highest_prio equals answer (3 points in that category)
    score = ifelse(highest_prio == answer, 3, 0),
    
    # Case 2: highest_prio is 1, 2, or 3, and answer is in {2, 3, 4} but not equal to highest_prio (1 point in answer's category)
    score = score + ifelse(highest_prio %in% 1:3 & answer %in% 2:4 & answer != highest_prio, 1, 0),
    
    # Case 3: answer is 5, 6, 7, or 8 (deduct 2 points in mapped category)
    score = score + ifelse(answer %in% 5:8, -2, 0),
    
    # Map category for Case 3's penalty
    score_category = case_when(
      highest_prio == answer ~ highest_prio,
      highest_prio %in% 1:3 & answer %in% 2:4 & answer != highest_prio ~ answer,
      answer %in% 5:8 ~ penalty_map[as.character(answer)]
    )
  ) %>%
  ungroup() %>%
  # Select and tally scores per participant and category
  group_by(participant, score_category) %>%
  summarise(total_score = sum(score, na.rm = TRUE), .groups = 'drop') %>%
  # Convert categories into separate columns
  pivot_wider(names_from = score_category, values_from = total_score, names_prefix = "category_", values_fill = list(total_score = 0))

scores



```





